"""
Enhanced authentication service
Comprehensive authentication, session management, and security features
"""

from datetime import datetime, timedelta
from typing import Optional, Dict, Any, Tuple
from sqlalchemy.orm import Session
from fastapi import HTTPException, status, Request

from models.user import User, UserStatus
from schemas.auth import LoginRequest, RegisterRequest, TokenResponse, ChangePasswordRequest
from core.security import get_security_manager
from .user_service import UserService
from .token_service import TokenService


class AuthenticationService:
    """Enhanced authentication service with comprehensive security features"""
    
    def __init__(self):
        self.security_manager = get_security_manager()
        self.user_service = UserService()
        self.token_service = TokenService()
    
    async def register_user(self, session: Session, register_data: RegisterRequest) -> Tuple[User, str]:
        \"\"\"Register a new user and return user with verification token\"\"\"\n        # Create user\n        from schemas.user import UserCreate\n        user_create = UserCreate(\n            email=register_data.email,\n            password=register_data.password,\n            first_name=register_data.first_name,\n            last_name=register_data.last_name,\n            username=register_data.username\n        )\n        \n        user = await self.user_service.create_user(session, user_create)\n        \n        # Create email verification token\n        verification_token, _ = await self.token_service.create_email_verification_token(\n            session, str(user.id), user.email\n        )\n        \n        return user, verification_token\n    \n    async def login_user(\n        self, \n        session: Session, \n        login_data: LoginRequest,\n        request: Optional[Request] = None\n    ) -> TokenResponse:\n        \"\"\"Authenticate user and return tokens\"\"\"\n        ip_address = None\n        user_agent = None\n        \n        if request:\n            ip_address = request.client.host if request.client else None\n            user_agent = request.headers.get(\"user-agent\")\n        \n        # Check if IP is blocked\n        if ip_address and self.security_manager.is_ip_blocked(ip_address):\n            raise HTTPException(\n                status_code=status.HTTP_429_TOO_MANY_REQUESTS,\n                detail=\"IP address temporarily blocked due to failed attempts\"\n            )\n        \n        # Authenticate user\n        user = await self.user_service.authenticate_user(\n            session, login_data.email, login_data.password\n        )\n        \n        if not user:\n            # Record failed attempt\n            if ip_address:\n                self.security_manager.record_failed_attempt(login_data.email, ip_address)\n            \n            # Try to get user for failed attempt tracking\n            user_for_tracking = await self.user_service.get_user_by_email(session, login_data.email)\n            if user_for_tracking:\n                await self.user_service.increment_failed_login_attempts(session, str(user_for_tracking.id))\n            \n            raise HTTPException(\n                status_code=status.HTTP_401_UNAUTHORIZED,\n                detail=\"Invalid email or password\",\n                headers={\"WWW-Authenticate\": \"Bearer\"},\n            )\n        \n        # Clear failed attempts on successful login\n        if ip_address:\n            self.security_manager.clear_failed_attempts(login_data.email, ip_address)\n        \n        # Check if user can login\n        if not user.can_login():\n            detail = \"Account is inactive\"\n            if user.is_locked:\n                detail = \"Account is temporarily locked due to failed login attempts\"\n            elif user.status == UserStatus.SUSPENDED:\n                detail = \"Account is suspended\"\n            elif user.status == UserStatus.PENDING_VERIFICATION:\n                detail = \"Account is pending email verification\"\n            \n            raise HTTPException(\n                status_code=status.HTTP_403_FORBIDDEN,\n                detail=detail\n            )\n        \n        # Create tokens\n        access_token_data = {\n            \"sub\": user.email,\n            \"user_id\": str(user.id),\n            \"email\": user.email,\n            \"username\": user.username,\n            \"roles\": [user.role.value],\n            \"permissions\": self._get_user_permissions(user)\n        }\n        \n        # Set token expiry based on remember_me\n        access_expires = timedelta(minutes=self.security_manager.access_token_expire_minutes)\n        refresh_expires = timedelta(days=7)  # Default refresh token expiry\n        \n        if login_data.remember_me:\n            access_expires = timedelta(hours=24)  # Longer access token for remember me\n            refresh_expires = timedelta(days=30)  # Longer refresh token\n        \n        # Create tokens\n        access_token = self.security_manager.create_access_token(\n            access_token_data, expires_delta=access_expires\n        )\n        \n        refresh_token, _ = await self.token_service.create_refresh_token(\n            session, str(user.id), user_agent, ip_address, refresh_expires\n        )\n        \n        return TokenResponse(\n            access_token=access_token,\n            refresh_token=refresh_token,\n            token_type=\"bearer\",\n            expires_in=int(access_expires.total_seconds()),\n            user={\n                \"id\": str(user.id),\n                \"email\": user.email,\n                \"username\": user.username,\n                \"first_name\": user.first_name,\n                \"last_name\": user.last_name,\n                \"role\": user.role.value,\n                \"is_verified\": user.is_verified\n            }\n        )\n    \n    async def refresh_token(self, session: Session, refresh_token: str) -> TokenResponse:\n        \"\"\"Refresh access token using refresh token\"\"\"\n        # Validate refresh token\n        token_record = await self.token_service.validate_refresh_token(session, refresh_token)\n        if not token_record:\n            raise HTTPException(\n                status_code=status.HTTP_401_UNAUTHORIZED,\n                detail=\"Invalid or expired refresh token\"\n            )\n        \n        # Get user\n        user = await self.user_service.get_user_by_id(session, str(token_record.user_id))\n        if not user or not user.can_login():\n            # Revoke the refresh token if user can't login\n            await self.token_service.revoke_refresh_token(session, refresh_token)\n            raise HTTPException(\n                status_code=status.HTTP_401_UNAUTHORIZED,\n                detail=\"User account is not active\"\n            )\n        \n        # Create new access token\n        access_token_data = {\n            \"sub\": user.email,\n            \"user_id\": str(user.id),\n            \"email\": user.email,\n            \"username\": user.username,\n            \"roles\": [user.role.value],\n            \"permissions\": self._get_user_permissions(user)\n        }\n        \n        access_token = self.security_manager.create_access_token(access_token_data)\n        \n        # Create new refresh token (rotate refresh tokens for security)\n        new_refresh_token, _ = await self.token_service.create_refresh_token(\n            session, str(user.id), token_record.device_info, token_record.ip_address\n        )\n        \n        # Revoke old refresh token\n        await self.token_service.revoke_refresh_token(session, refresh_token)\n        \n        return TokenResponse(\n            access_token=access_token,\n            refresh_token=new_refresh_token,\n            token_type=\"bearer\",\n            expires_in=self.security_manager.access_token_expire_minutes * 60,\n            user={\n                \"id\": str(user.id),\n                \"email\": user.email,\n                \"username\": user.username,\n                \"first_name\": user.first_name,\n                \"last_name\": user.last_name,\n                \"role\": user.role.value,\n                \"is_verified\": user.is_verified\n            }\n        )\n    \n    async def logout_user(self, session: Session, refresh_token: str) -> bool:\n        \"\"\"Logout user by revoking refresh token\"\"\"\n        return await self.token_service.revoke_refresh_token(session, refresh_token)\n    \n    async def logout_all_sessions(self, session: Session, user_id: str) -> int:\n        \"\"\"Logout user from all sessions by revoking all refresh tokens\"\"\"\n        return await self.token_service.revoke_user_refresh_tokens(session, user_id)\n    \n    async def change_password(\n        self, \n        session: Session, \n        user_id: str, \n        change_password_data: ChangePasswordRequest\n    ) -> bool:\n        \"\"\"Change user password\"\"\"\n        success = await self.user_service.change_password(\n            session, \n            user_id, \n            change_password_data.current_password, \n            change_password_data.new_password\n        )\n        \n        if success:\n            # Revoke all refresh tokens to force re-login\n            await self.token_service.revoke_user_refresh_tokens(session, user_id)\n        \n        return success\n    \n    async def initiate_password_reset(self, session: Session, email: str) -> Optional[str]:\n        \"\"\"Initiate password reset process\"\"\"\n        user = await self.user_service.get_user_by_email(session, email)\n        if not user:\n            # Don't reveal if user exists\n            return None\n        \n        # Create password reset token\n        reset_token, _ = await self.token_service.create_password_reset_token(\n            session, str(user.id)\n        )\n        \n        return reset_token\n    \n    async def confirm_password_reset(\n        self, \n        session: Session, \n        token: str, \n        new_password: str\n    ) -> bool:\n        \"\"\"Confirm password reset with token\"\"\"\n        # Validate token\n        token_record = await self.token_service.validate_password_reset_token(session, token)\n        if not token_record:\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=\"Invalid or expired reset token\"\n            )\n        \n        # Reset password\n        success = await self.user_service.reset_password(\n            session, str(token_record.user_id), new_password\n        )\n        \n        if success:\n            # Mark token as used\n            await self.token_service.use_password_reset_token(session, token)\n            # Revoke all refresh tokens\n            await self.token_service.revoke_user_refresh_tokens(session, str(token_record.user_id))\n        \n        return success\n    \n    async def verify_email(self, session: Session, token: str) -> bool:\n        \"\"\"Verify user email with token\"\"\"\n        # Validate and use token\n        token_record = await self.token_service.use_email_verification_token(session, token)\n        if not token_record:\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=\"Invalid or expired verification token\"\n            )\n        \n        # Verify email\n        return await self.user_service.verify_email(session, str(token_record.user_id))\n    \n    async def resend_verification_email(self, session: Session, email: str) -> Optional[str]:\n        \"\"\"Resend email verification\"\"\"\n        user = await self.user_service.get_user_by_email(session, email)\n        if not user:\n            return None\n        \n        if user.is_verified:\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=\"Email is already verified\"\n            )\n        \n        # Create new verification token\n        verification_token, _ = await self.token_service.create_email_verification_token(\n            session, str(user.id), user.email\n        )\n        \n        return verification_token\n    \n    async def get_current_user_info(self, session: Session, user_id: str) -> Optional[Dict[str, Any]]:\n        \"\"\"Get current user information\"\"\"\n        user = await self.user_service.get_user_by_id(session, user_id)\n        if not user:\n            return None\n        \n        profile = await self.user_service.get_user_profile(session, user_id)\n        preferences = await self.user_service.get_user_preferences(session, user_id)\n        token_stats = await self.token_service.get_user_token_stats(session, user_id)\n        \n        return {\n            \"id\": str(user.id),\n            \"email\": user.email,\n            \"username\": user.username,\n            \"first_name\": user.first_name,\n            \"last_name\": user.last_name,\n            \"role\": user.role.value,\n            \"status\": user.status.value,\n            \"is_verified\": user.is_verified,\n            \"is_active\": user.is_active,\n            \"created_at\": user.created_at,\n            \"updated_at\": user.updated_at,\n            \"last_login_at\": user.last_login_at,\n            \"two_factor_enabled\": user.two_factor_enabled,\n            \"profile\": profile.__dict__ if profile else None,\n            \"preferences\": preferences.__dict__ if preferences else None,\n            \"session_info\": token_stats\n        }\n    \n    def _get_user_permissions(self, user: User) -> list[str]:\n        \"\"\"Get user permissions based on role\"\"\"\n        permissions = [\"read\"]  # Basic read permission for all users\n        \n        if user.role.value in [\"user\"]:\n            permissions.extend([\"write\", \"profile:update\", \"preferences:update\"])\n        \n        if user.role.value in [\"admin\", \"super_admin\"]:\n            permissions.extend([\n                \"write\", \"admin\", \"users:manage\", \"roles:manage\",\n                \"system:configure\", \"reports:view\", \"analytics:view\"\n            ])\n        \n        if user.role.value == \"super_admin\":\n            permissions.extend([\"system:admin\", \"users:delete\", \"system:reset\"])\n        \n        return permissions