1:"$Sreact.fragment"
3:I["(app-pages-browser)/./node_modules/next/dist/client/components/layout-router.js",["app-pages-internals","static/chunks/app-pages-internals.js"],""]
4:I["(app-pages-browser)/./node_modules/next/dist/client/components/render-from-template-context.js",["app-pages-internals","static/chunks/app-pages-internals.js"],""]
6:I["(app-pages-browser)/./components/theme-provider.tsx",["app/layout","static/chunks/app/layout.js"],"ThemeProvider"]
7:I["(app-pages-browser)/./components/auth/auth-error-boundary.tsx",["app/layout","static/chunks/app/layout.js"],"AuthErrorBoundary"]
8:I["(app-pages-browser)/./lib/auth-context.tsx",["app/layout","static/chunks/app/layout.js"],"AuthProvider"]
9:I["(app-pages-browser)/./components/providers/ArketicProvider.tsx",["app/layout","static/chunks/app/layout.js"],"ArketicProvider"]
a:I["(app-pages-browser)/./app/not-found.tsx",["app/not-found","static/chunks/app/not-found.js"],"default"]
b:I["(app-pages-browser)/./node_modules/sonner/dist/index.mjs",["app/layout","static/chunks/app/layout.js"],"Toaster"]
c:I["(app-pages-browser)/./node_modules/next/dist/client/components/client-page.js",["app-pages-internals","static/chunks/app-pages-internals.js"],"ClientPageRoot"]
d:I["(app-pages-browser)/./app/dashboard/page.tsx",["app/dashboard/page","static/chunks/app/dashboard/page.js"],"default"]
e:I["(app-pages-browser)/./node_modules/next/dist/client/components/metadata/metadata-boundary.js",["app-pages-internals","static/chunks/app-pages-internals.js"],"OutletBoundary"]
15:I["(app-pages-browser)/./node_modules/next/dist/client/components/metadata/async-metadata.js",["app-pages-internals","static/chunks/app-pages-internals.js"],"AsyncMetadataOutlet"]
1a:I["(app-pages-browser)/./node_modules/next/dist/client/components/error-boundary.js",["app-pages-internals","static/chunks/app-pages-internals.js"],""]
1b:I["(app-pages-browser)/./node_modules/next/dist/client/components/client-segment.js",["app-pages-internals","static/chunks/app-pages-internals.js"],"ClientSegmentRoot"]
1c:I["(app-pages-browser)/./node_modules/next/dist/client/components/http-access-fallback/error-boundary.js",["app-pages-internals","static/chunks/app-pages-internals.js"],"HTTPAccessFallbackBoundary"]
1d:I["(app-pages-browser)/./node_modules/next/dist/client/components/metadata/metadata-boundary.js",["app-pages-internals","static/chunks/app-pages-internals.js"],"MetadataBoundary"]
1e:I["(app-pages-browser)/./node_modules/next/dist/client/components/metadata/metadata-boundary.js",["app-pages-internals","static/chunks/app-pages-internals.js"],"ViewportBoundary"]
2b:"$Sreact.suspense"
2c:I["(app-pages-browser)/./node_modules/next/dist/client/components/metadata/async-metadata.js",["app-pages-internals","static/chunks/app-pages-internals.js"],"AsyncMetadata"]
5:{"name":"RootLayout","env":"Server","key":null,"owner":null,"stack":[],"props":{"children":["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$1",null,{"children":["$","$L4",null,{},null,[],1]},null,[],0],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$Y","forbidden":"$undefined","unauthorized":"$undefined"},null,[],1],"params":"$Y"}}
2:D"$5"
2:["$","html",null,{"lang":"en","suppressHydrationWarning":true,"children":["$","body",null,{"className":"__className_e8ce0c","suppressHydrationWarning":true,"children":["$","$L6",null,{"attribute":"class","defaultTheme":"light","enableSystem":true,"disableTransitionOnChange":true,"children":["$","$L7",null,{"children":["$","$L8",null,{"children":["$","$L9",null,{"children":[["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{},null,[],1],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[["$","$La",null,{},null,[],1],[]],"forbidden":"$undefined","unauthorized":"$undefined"},null,[],1],["$","$Lb",null,{"position":"top-right","expand":true,"richColors":true,"closeButton":true,"duration":4000},"$5",[["RootLayout","webpack-internal:///(rsc)/./app/layout.tsx",49,108]],1]]},"$5",[["RootLayout","webpack-internal:///(rsc)/./app/layout.tsx",46,110]],1]},"$5",[["RootLayout","webpack-internal:///(rsc)/./app/layout.tsx",45,106]],1]},"$5",[["RootLayout","webpack-internal:///(rsc)/./app/layout.tsx",44,102]],1]},"$5",[["RootLayout","webpack-internal:///(rsc)/./app/layout.tsx",39,98]],1]},"$5",[["RootLayout","webpack-internal:///(rsc)/./app/layout.tsx",36,94]],1]},"$5",[["RootLayout","webpack-internal:///(rsc)/./app/layout.tsx",33,87]],1]
10:{"name":"__next_outlet_boundary__","env":"Server","key":null,"owner":null,"stack":[],"props":{"ready":"$E(async function getViewportReady() {\n        await viewport();\n        return undefined;\n    })"}}
f:D"$10"
12:{"name":"__next_outlet_boundary__","env":"Server","key":null,"owner":null,"stack":[],"props":{"ready":"$E(async function getMetadataReady() {\n        // Only warm up metadata() call when it's blocking metadata,\n        // otherwise it will be fully managed by AsyncMetadata component.\n        if (!serveStreamingMetadata) {\n            await metadata();\n        }\n        return undefined;\n    })"}}
11:D"$12"
14:{"name":"StreamingMetadataOutlet","env":"Server","key":null,"owner":null,"stack":[],"props":{}}
13:D"$14"
13:["$","$L15",null,{"promise":"$@16"},"$14",[],1]
18:{"name":"Loading","env":"Server","key":"l","owner":null,"stack":[],"props":{}}
17:D"$18"
17:null
1f:{"name":"NonIndex","env":"Server","key":null,"owner":null,"stack":[],"props":{"ctx":{"componentMod":{"GlobalError":"$1a","__next_app__":{"require":"$E(function __webpack_require__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\tvar threw = true;\n/******/ \t\ttry {\n/******/ \t\t\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n/******/ \t\t\tthrew = false;\n/******/ \t\t} finally {\n/******/ \t\t\tif(threw) delete __webpack_module_cache__[moduleId];\n/******/ \t\t}\n/******/ \t\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t})","loadChunk":"$E(() => Promise.resolve())"},"pages":["/app/app/dashboard/page.tsx"],"routeModule":{"userland":{"loaderTree":["","$Y","$Y"]},"definition":"$Y"},"tree":"$Y","ClientPageRoot":"$c","ClientSegmentRoot":"$1b","HTTPAccessFallbackBoundary":"$1c","LayoutRouter":"$3","MetadataBoundary":"$1d","OutletBoundary":"$e","Postpone":"$E(function Postpone({ reason, route }) {\n    const prerenderStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();\n    const dynamicTracking = prerenderStore && prerenderStore.type === 'prerender-ppr' ? prerenderStore.dynamicTracking : null;\n    postponeWithTracking(route, reason, dynamicTracking);\n})","RenderFromTemplateContext":"$4","ViewportBoundary":"$1e","actionAsyncStorage":"$Y","collectSegmentData":"$E(async function collectSegmentData(shouldAssumePartialData, fullPageDataBuffer, staleTime, clientModules, serverConsumerManifest, fallbackRouteParams) {\n    // Traverse the router tree and generate a prefetch response for each segment.\n    // A mutable map to collect the results as we traverse the route tree.\n    const resultMap = new Map();\n    // Before we start, warm up the module cache by decoding the page data once.\n    // Then we can assume that any remaining async tasks that occur the next time\n    // are due to hanging promises caused by dynamic data access. Note we only\n    // have to do this once per page, not per individual segment.\n    //\n    try {\n        await (0, _clientedge.createFromReadableStream)((0, _nodewebstreamshelper.streamFromBuffer)(fullPageDataBuffer), {\n            serverConsumerManifest\n        });\n        await (0, _scheduler.waitAtLeastOneReactRenderTask)();\n    } catch  {}\n    // Create an abort controller that we'll use to stop the stream.\n    const abortController = new AbortController();\n    const onCompletedProcessingRouteTree = async ()=>{\n        // Since all we're doing is decoding and re-encoding a cached prerender, if\n        // serializing the stream takes longer than a microtask, it must because of\n        // hanging promises caused by dynamic data.\n        await (0, _scheduler.waitAtLeastOneReactRenderTask)();\n        abortController.abort();\n    };\n    // Generate a stream for the route tree prefetch. While we're walking the\n    // tree, we'll also spawn additional tasks to generate the segment prefetches.\n    // The promises for these tasks are pushed to a mutable array that we will\n    // await once the route tree is fully rendered.\n    const segmentTasks = [];\n    const { prelude: treeStream } = await (0, _staticedge.unstable_prerender)(// RootTreePrefetch is not a valid return type for a React component, but\n    // we need to use a component so that when we decode the original stream\n    // inside of it, the side effects are transferred to the new stream.\n    // @ts-expect-error\n    /*#__PURE__*/ (0, _jsxruntime.jsx)(PrefetchTreeData, {\n        shouldAssumePartialData: shouldAssumePartialData,\n        fullPageDataBuffer: fullPageDataBuffer,\n        fallbackRouteParams: fallbackRouteParams,\n        serverConsumerManifest: serverConsumerManifest,\n        clientModules: clientModules,\n        staleTime: staleTime,\n        segmentTasks: segmentTasks,\n        onCompletedProcessingRouteTree: onCompletedProcessingRouteTree\n    }), clientModules, {\n        signal: abortController.signal,\n        onError: onSegmentPrerenderError\n    });\n    // Write the route tree to a special `/_tree` segment.\n    const treeBuffer = await (0, _nodewebstreamshelper.streamToBuffer)(treeStream);\n    resultMap.set('/_tree', treeBuffer);\n    // Now that we've finished rendering the route tree, all the segment tasks\n    // should have been spawned. Await them in parallel and write the segment\n    // prefetches to the result map.\n    for (const [segmentPath, buffer] of (await Promise.all(segmentTasks))){\n        resultMap.set(segmentPath, buffer);\n    }\n    return resultMap;\n})","createMetadataComponents":"$E(function createMetadataComponents({ tree, searchParams, metadataContext, getDynamicParamFromSegment, appUsingSizeAdjustment, errorType, createServerParamsForMetadata, workStore, MetadataBoundary, ViewportBoundary, serveStreamingMetadata }) {\n    function ViewportTree() {\n        return /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {\n            children: [\n                /*#__PURE__*/ (0, _jsxruntime.jsx)(ViewportBoundary, {\n                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)(Viewport, {})\n                }),\n                appUsingSizeAdjustment ? /*#__PURE__*/ (0, _jsxruntime.jsx)(\"meta\", {\n                    name: \"next-size-adjust\",\n                    content: \"\"\n                }) : null\n            ]\n        });\n    }\n    function MetadataTree() {\n        return /*#__PURE__*/ (0, _jsxruntime.jsx)(MetadataBoundary, {\n            children: /*#__PURE__*/ (0, _jsxruntime.jsx)(Metadata, {})\n        });\n    }\n    function viewport() {\n        return getResolvedViewport(tree, searchParams, getDynamicParamFromSegment, createServerParamsForMetadata, workStore, errorType);\n    }\n    async function Viewport() {\n        try {\n            return await viewport();\n        } catch (error) {\n            if (!errorType && (0, _httpaccessfallback.isHTTPAccessFallbackError)(error)) {\n                try {\n                    return await getNotFoundViewport(tree, searchParams, getDynamicParamFromSegment, createServerParamsForMetadata, workStore);\n                } catch  {}\n            }\n            // We don't actually want to error in this component. We will\n            // also error in the MetadataOutlet which causes the error to\n            // bubble from the right position in the page to be caught by the\n            // appropriate boundaries\n            return null;\n        }\n    }\n    Viewport.displayName = _metadataconstants.VIEWPORT_BOUNDARY_NAME;\n    function metadata() {\n        return getResolvedMetadata(tree, searchParams, getDynamicParamFromSegment, metadataContext, createServerParamsForMetadata, workStore, errorType);\n    }\n    async function resolveFinalMetadata() {\n        let result;\n        let error = null;\n        try {\n            result = await metadata();\n            return {\n                metadata: result,\n                error: null,\n                digest: undefined\n            };\n        } catch (metadataErr) {\n            error = metadataErr;\n            if (!errorType && (0, _httpaccessfallback.isHTTPAccessFallbackError)(metadataErr)) {\n                try {\n                    result = await getNotFoundMetadata(tree, searchParams, getDynamicParamFromSegment, metadataContext, createServerParamsForMetadata, workStore);\n                    return {\n                        metadata: result,\n                        error,\n                        digest: error == null ? void 0 : error.digest\n                    };\n                } catch (notFoundMetadataErr) {\n                    error = notFoundMetadataErr;\n                    // In PPR rendering we still need to throw the postpone error.\n                    // If metadata is postponed, React needs to be aware of the location of error.\n                    if (serveStreamingMetadata && (0, _ispostpone.isPostpone)(notFoundMetadataErr)) {\n                        throw notFoundMetadataErr;\n                    }\n                }\n            }\n            // In PPR rendering we still need to throw the postpone error.\n            // If metadata is postponed, React needs to be aware of the location of error.\n            if (serveStreamingMetadata && (0, _ispostpone.isPostpone)(metadataErr)) {\n                throw metadataErr;\n            }\n            // We don't actually want to error in this component. We will\n            // also error in the MetadataOutlet which causes the error to\n            // bubble from the right position in the page to be caught by the\n            // appropriate boundaries\n            return {\n                metadata: result,\n                error,\n                digest: error == null ? void 0 : error.digest\n            };\n        }\n    }\n    async function Metadata() {\n        const promise = resolveFinalMetadata();\n        if (serveStreamingMetadata) {\n            return /*#__PURE__*/ (0, _jsxruntime.jsx)(_react.Suspense, {\n                fallback: null,\n                children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_asyncmetadata.AsyncMetadata, {\n                    promise: promise\n                })\n            });\n        }\n        const metadataState = await promise;\n        return metadataState.metadata;\n    }\n    Metadata.displayName = _metadataconstants.METADATA_BOUNDARY_NAME;\n    async function getMetadataReady() {\n        // Only warm up metadata() call when it's blocking metadata,\n        // otherwise it will be fully managed by AsyncMetadata component.\n        if (!serveStreamingMetadata) {\n            await metadata();\n        }\n        return undefined;\n    }\n    async function getViewportReady() {\n        await viewport();\n        return undefined;\n    }\n    function StreamingMetadataOutlet() {\n        if (serveStreamingMetadata) {\n            return /*#__PURE__*/ (0, _jsxruntime.jsx)(_asyncmetadata.AsyncMetadataOutlet, {\n                promise: resolveFinalMetadata()\n            });\n        }\n        return null;\n    }\n    return {\n        ViewportTree,\n        MetadataTree,\n        getViewportReady,\n        getMetadataReady,\n        StreamingMetadataOutlet\n    };\n})","createPrerenderParamsForClientSegment":"$E(function createPrerenderParamsForClientSegment(underlyingParams, workStore) {\n    const prerenderStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();\n    if (prerenderStore && prerenderStore.type === 'prerender') {\n        const fallbackParams = workStore.fallbackRouteParams;\n        if (fallbackParams) {\n            for(let key in underlyingParams){\n                if (fallbackParams.has(key)) {\n                    // This params object has one of more fallback params so we need to consider\n                    // the awaiting of this params object \"dynamic\". Since we are in dynamicIO mode\n                    // we encode this as a promise that never resolves\n                    return (0, _dynamicrenderingutils.makeHangingPromise)(prerenderStore.renderSignal, '`params`');\n                }\n            }\n        }\n    }\n    // We're prerendering in a mode that does not abort. We resolve the promise without\n    // any tracking because we're just transporting a value from server to client where the tracking\n    // will be applied.\n    return Promise.resolve(underlyingParams);\n})","createPrerenderSearchParamsForClientPage":"$E(function createPrerenderSearchParamsForClientPage(workStore) {\n    if (workStore.forceStatic) {\n        // When using forceStatic we override all other logic and always just return an empty\n        // dictionary object.\n        return Promise.resolve({});\n    }\n    const prerenderStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();\n    if (prerenderStore && prerenderStore.type === 'prerender') {\n        // dynamicIO Prerender\n        // We're prerendering in a mode that aborts (dynamicIO) and should stall\n        // the promise to ensure the RSC side is considered dynamic\n        return (0, _dynamicrenderingutils.makeHangingPromise)(prerenderStore.renderSignal, '`searchParams`');\n    }\n    // We're prerendering in a mode that does not aborts. We resolve the promise without\n    // any tracking because we're just transporting a value from server to client where the tracking\n    // will be applied.\n    return Promise.resolve({});\n})","createServerParamsForMetadata":"$E(function createServerParamsForServerSegment(underlyingParams, workStore) {\n    const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();\n    if (workUnitStore) {\n        switch(workUnitStore.type){\n            case 'prerender':\n            case 'prerender-ppr':\n            case 'prerender-legacy':\n                return createPrerenderParams(underlyingParams, workStore, workUnitStore);\n            default:\n        }\n    }\n    return createRenderParams(underlyingParams, workStore);\n})","createServerParamsForServerSegment":"$E(function createServerParamsForServerSegment(underlyingParams, workStore) {\n    const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();\n    if (workUnitStore) {\n        switch(workUnitStore.type){\n            case 'prerender':\n            case 'prerender-ppr':\n            case 'prerender-legacy':\n                return createPrerenderParams(underlyingParams, workStore, workUnitStore);\n            default:\n        }\n    }\n    return createRenderParams(underlyingParams, workStore);\n})","createServerSearchParamsForMetadata":"$E(function createServerSearchParamsForServerPage(underlyingSearchParams, workStore) {\n    const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();\n    if (workUnitStore) {\n        switch(workUnitStore.type){\n            case 'prerender':\n            case 'prerender-ppr':\n            case 'prerender-legacy':\n                return createPrerenderSearchParams(workStore, workUnitStore);\n            default:\n        }\n    }\n    return createRenderSearchParams(underlyingSearchParams, workStore);\n})","createServerSearchParamsForServerPage":"$E(function createServerSearchParamsForServerPage(underlyingSearchParams, workStore) {\n    const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();\n    if (workUnitStore) {\n        switch(workUnitStore.type){\n            case 'prerender':\n            case 'prerender-ppr':\n            case 'prerender-legacy':\n                return createPrerenderSearchParams(workStore, workUnitStore);\n            default:\n        }\n    }\n    return createRenderSearchParams(underlyingSearchParams, workStore);\n})","createTemporaryReferenceSet":"$E(function(){return new WeakMap})","decodeAction":"$E(function(body,serverManifest){var formData=new FormData,action=null;return body.forEach(function(value1,key){key.startsWith(\"$ACTION_\")?key.startsWith(\"$ACTION_REF_\")?(value1=decodeBoundActionMetaData(body,serverManifest,value1=\"$ACTION_\"+key.slice(12)+\":\"),action=loadServerReference(serverManifest,value1.id,value1.bound)):key.startsWith(\"$ACTION_ID_\")&&(action=loadServerReference(serverManifest,value1=key.slice(11),null)):formData.append(key,value1)}),null===action?null:action.then(function(fn){return fn.bind(null,formData)})})","decodeFormState":"$E(function(actionResult,body,serverManifest){var keyPath=body.get(\"$ACTION_KEY\");if(\"string\"!=typeof keyPath)return Promise.resolve(null);var metaData=null;if(body.forEach(function(value1,key){key.startsWith(\"$ACTION_REF_\")&&(metaData=decodeBoundActionMetaData(body,serverManifest,\"$ACTION_\"+key.slice(12)+\":\"))}),null===metaData)return Promise.resolve(null);var referenceId=metaData.id;return Promise.resolve(metaData.bound).then(function(bound){return null===bound?null:[actionResult,keyPath,referenceId,bound.length-1]})})","decodeReply":"$E(function(body,webpackMap,options){if(\"string\"==typeof body){var form=new FormData;form.append(\"0\",body),body=form}return webpackMap=getChunk(body=createResponse(webpackMap,\"\",options?options.temporaryReferences:void 0,body),0),close(body),webpackMap})","patchFetch":"$E(function patchFetch() {\n    return (0, _patchfetch.patchFetch)({\n        workAsyncStorage: _workasyncstorageexternal.workAsyncStorage,\n        workUnitAsyncStorage: _workunitasyncstorageexternal.workUnitAsyncStorage\n    });\n})","preconnect":"$E(function preconnect(href, crossOrigin, nonce) {\n    const opts = {};\n    if (typeof crossOrigin === 'string') {\n        opts.crossOrigin = crossOrigin;\n    }\n    if (typeof nonce === 'string') {\n        opts.nonce = nonce;\n    }\n    ;\n    _reactdom.default.preconnect(href, opts);\n})","preloadFont":"$E(function preloadFont(href, type, crossOrigin, nonce) {\n    const opts = {\n        as: 'font',\n        type\n    };\n    if (typeof crossOrigin === 'string') {\n        opts.crossOrigin = crossOrigin;\n    }\n    if (typeof nonce === 'string') {\n        opts.nonce = nonce;\n    }\n    _reactdom.default.preload(href, opts);\n})","preloadStyle":"$E(function preloadStyle(href, crossOrigin, nonce) {\n    const opts = {\n        as: 'style'\n    };\n    if (typeof crossOrigin === 'string') {\n        opts.crossOrigin = crossOrigin;\n    }\n    if (typeof nonce === 'string') {\n        opts.nonce = nonce;\n    }\n    _reactdom.default.preload(href, opts);\n})","prerender":"$E(function(model,webpackMap,options){return new Promise(function(resolve,reject){var request=new RequestInstance(PRERENDER,model,webpackMap,options?options.onError:void 0,options?options.identifierPrefix:void 0,options?options.onPostpone:void 0,options?options.temporaryReferences:void 0,options?options.environmentName:void 0,options?options.filterStackFrame:void 0,function(){resolve({prelude:new ReadableStream({type:\"bytes\",start:function(){startWork(request)},pull:function(controller){startFlowing(request,controller)},cancel:function(reason){request.destination=null,abort(request,reason)}},{highWaterMark:0})})},reject);if(options&&options.signal){var signal=options.signal;if(signal.aborted)abort(request,signal.reason);else{var listener=function(){abort(request,signal.reason),signal.removeEventListener(\"abort\",listener)};signal.addEventListener(\"abort\",listener)}}startWork(request)})})","renderToReadableStream":"$E(function(model,webpackMap,options){var request=new RequestInstance(20,model,webpackMap,options?options.onError:void 0,options?options.identifierPrefix:void 0,options?options.onPostpone:void 0,options?options.temporaryReferences:void 0,options?options.environmentName:void 0,options?options.filterStackFrame:void 0,noop,noop);if(options&&options.signal){var signal=options.signal;if(signal.aborted)abort(request,signal.reason);else{var listener=function(){abort(request,signal.reason),signal.removeEventListener(\"abort\",listener)};signal.addEventListener(\"abort\",listener)}}return new ReadableStream({type:\"bytes\",start:function(){startWork(request)},pull:function(controller){startFlowing(request,controller)},cancel:function(reason){request.destination=null,abort(request,reason)}},{highWaterMark:0})})","serverHooks":"$Y","taintObjectReference":"$E(function notImplemented() {\n    throw Object.defineProperty(new Error('Taint can only be used with the taint flag.'), \"__NEXT_ERROR_CODE\", {\n        value: \"E354\",\n        enumerable: false,\n        configurable: true\n    });\n})","workAsyncStorage":"$Y","workUnitAsyncStorage":"$Y"},"url":"$Y","renderOpts":"$Y","workStore":"$Y","parsedRequestHeaders":"$Y","getDynamicParamFromSegment":"$E(function(segment){let segmentParam=getSegmentParam(segment);if(!segmentParam)return null;let key=segmentParam.param,value1=params[key];if(fallbackRouteParams&&fallbackRouteParams.has(segmentParam.param)?value1=fallbackRouteParams.get(segmentParam.param):Array.isArray(value1)?value1=value1.map(i=>encodeURIComponent(i)):\"string\"==typeof value1&&(value1=encodeURIComponent(value1)),!value1){let isCatchall=\"catchall\"===segmentParam.type,isOptionalCatchall=\"optional-catchall\"===segmentParam.type;if(isCatchall||isOptionalCatchall){let dynamicParamType=dynamicParamTypes[segmentParam.type];return isOptionalCatchall?{param:key,value:null,type:dynamicParamType,treeSegment:[key,\"\",dynamicParamType]}:{param:key,value:value1=pagePath.split(\"/\").slice(1).flatMap(pathSegment=>{let param=function(param){let match=param.match(PARAMETER_PATTERN);return match?parseMatchedParameter(match[2]):parseMatchedParameter(param)}(pathSegment);return params[param.key]??param.key}),type:dynamicParamType,treeSegment:[key,value1.join(\"/\"),dynamicParamType]}}}let type=function(type){let short=dynamicParamTypes[type];if(!short)throw Object.defineProperty(Error(\"Unknown dynamic param type\"),\"__NEXT_ERROR_CODE\",{value:\"E378\",enumerable:!1,configurable:!0});return short}(segmentParam.type);return{param:key,value:value1,treeSegment:[key,Array.isArray(value1)?value1.join(\"/\"):value1,type],type:type}})","query":"$0:f:0:1:2:children:2:children:1:props:children:0:props:searchParams","isPrefetch":false,"isAction":false,"requestTimestamp":1754854308600,"appUsingSizeAdjustment":true,"flightRouterState":"$Y","requestId":"quFyBGkRI6Ku30_18jGfl","pagePath":"/dashboard","clientReferenceManifest":"$Y","assetPrefix":"","isNotFoundPath":false,"nonce":"$undefined","res":"$Y","sharedContext":"$Y"}}}
19:D"$1f"
19:null
21:{"name":"ViewportTree","env":"Server","key":"quFyBGkRI6Ku30_18jGfl","owner":null,"stack":[],"props":{}}
20:D"$21"
23:{"name":"__next_viewport_boundary__","env":"Server","key":null,"owner":"$21","stack":[],"props":{}}
22:D"$23"
20:["$","$1","quFyBGkRI6Ku30_18jGfl",{"children":[["$","$L1e",null,{"children":"$L22"},"$21",[],1],["$","meta",null,{"name":"next-size-adjust","content":""},"$21",[],1]]},null,null,0]
25:{"name":"","env":"Server","key":null,"owner":null,"stack":[],"props":{}}
24:D"$25"
26:{"name":"MetadataTree","env":"Server","key":"quFyBGkRI6Ku30_18jGfl","owner":null,"stack":[],"props":{}}
24:D"$26"
28:{"name":"__next_metadata_boundary__","env":"Server","key":null,"owner":"$26","stack":[],"props":{}}
27:D"$28"
24:[["$","$L1d","quFyBGkRI6Ku30_18jGfl",{"children":"$L27"},"$26",[],1]]
2a:{"name":"","env":"Server","key":null,"owner":null,"stack":[],"props":{}}
29:D"$2a"
29:null
0:{"b":"development","f":[[["",{"children":["dashboard",{"children":["__PAGE__",{}]}]},"$undefined","$undefined",true],["",["$","$1","c",{"children":[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/app/layout.css?v=1754854308600","precedence":"next_static/css/app/layout.css","crossOrigin":"$undefined","nonce":"$undefined"},null,[],0]],"$2"]},null,[],0],{"children":["dashboard",["$","$1","c",{"children":[null,["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{},null,[],1],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"},null,[],1]]},null,[],0],{"children":["__PAGE__",["$","$1","c",{"children":[["$","$Lc",null,{"Component":"$d","searchParams":{},"params":{}},null,[],1],"$undefined",null,["$","$Le",null,{"children":["$Lf","$L11","$13"]},null,[],1]]},null,[],0],{},null,false]},null,false]},["$17",[],[]],false],["$","$1","h",{"children":["$19","$20","$24","$29"]},null,[],0],false]],"S":false}
27:["$","$2b",null,{"fallback":null,"children":["$","$L2c",null,{"promise":"$@2d"},"$28",[],1]},"$28",[],1]
11:null
22:[["$","meta","0",{"charSet":"utf-8"},"$10",[],0],["$","meta","1",{"name":"viewport","content":"width=device-width, initial-scale=1"},"$10",[],0]]
16:{"metadata":[["$","title","0",{"children":"Arketic AI Platform - Analytics Dashboard"},"$14",[],0],["$","meta","1",{"name":"description","content":"A comprehensive AI platform with advanced analytics and data visualization"},"$14",[],0],["$","meta","2",{"name":"generator","content":"v0.dev"},"$14",[],0],["$","link","3",{"rel":"icon","href":"/favicon.ico"},"$14",[],0]],"error":null,"digest":"$undefined"}
2d:{"metadata":"$16:metadata","error":null,"digest":"$undefined"}
f:null
